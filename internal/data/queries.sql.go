// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package data

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (owner_id, title, description, starts_at, ends_at, location, unique_link, privacy_setting,
                    created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id
`

type CreateEventParams struct {
	OwnerID        int32
	Title          string
	Description    pgtype.Text
	StartsAt       pgtype.Timestamptz
	EndsAt         pgtype.Timestamptz
	Location       pgtype.Text
	UniqueLink     pgtype.Text
	PrivacySetting string
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (int32, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.OwnerID,
		arg.Title,
		arg.Description,
		arg.StartsAt,
		arg.EndsAt,
		arg.Location,
		arg.UniqueLink,
		arg.PrivacySetting,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE
FROM events
WHERE id = $1
RETURNING id, owner_id, title, description, starts_at, ends_at, location, unique_link, privacy_setting, created_at, updated_at
`

func (q *Queries) DeleteEvent(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteEvent, id)
	return err
}

const getEvent = `-- name: GetEvent :one
SELECT id, owner_id, title, description, starts_at, ends_at, location, unique_link, privacy_setting, created_at, updated_at
FROM events
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetEvent(ctx context.Context, id int32) (Event, error) {
	row := q.db.QueryRow(ctx, getEvent, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Title,
		&i.Description,
		&i.StartsAt,
		&i.EndsAt,
		&i.Location,
		&i.UniqueLink,
		&i.PrivacySetting,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPastEvents = `-- name: ListPastEvents :many
SELECT e.id,
       e.owner_id,
       e.title,
       e.description,
       e.starts_at,
       e.ends_at,
       e.location,
       e.unique_link,
       e.privacy_setting,
       e.created_at,
       e.updated_at
FROM events e
         JOIN invitations i ON e.id = i.event_id
WHERE e.ends_at < $1
  AND i.user_id = $2
UNION
SELECT e.id,
       e.owner_id,
       e.title,
       e.description,
       e.starts_at,
       e.ends_at,
       e.location,
       e.unique_link,
       e.privacy_setting,
       e.created_at,
       e.updated_at
FROM events e
WHERE e.ends_at < $1
  AND e.owner_id = $2
ORDER BY starts_at DESC
`

type ListPastEventsParams struct {
	EndsAt pgtype.Timestamptz
	UserID int32
}

func (q *Queries) ListPastEvents(ctx context.Context, arg ListPastEventsParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, listPastEvents, arg.EndsAt, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Title,
			&i.Description,
			&i.StartsAt,
			&i.EndsAt,
			&i.Location,
			&i.UniqueLink,
			&i.PrivacySetting,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingInvitedEvents = `-- name: ListUpcomingInvitedEvents :many
SELECT e.id,
       e.owner_id,
       e.title,
       e.description,
       e.starts_at,
       e.ends_at,
       e.location,
       e.unique_link,
       e.privacy_setting,
       e.created_at,
       e.updated_at,
       i.status
FROM events e
         JOIN invitations i ON e.id = i.event_id
WHERE e.starts_at > $1
  AND i.user_id = $2
ORDER BY starts_at
`

type ListUpcomingInvitedEventsParams struct {
	StartsAt pgtype.Timestamptz
	UserID   int32
}

type ListUpcomingInvitedEventsRow struct {
	ID             int32
	OwnerID        int32
	Title          string
	Description    pgtype.Text
	StartsAt       pgtype.Timestamptz
	EndsAt         pgtype.Timestamptz
	Location       pgtype.Text
	UniqueLink     pgtype.Text
	PrivacySetting string
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	Status         string
}

func (q *Queries) ListUpcomingInvitedEvents(ctx context.Context, arg ListUpcomingInvitedEventsParams) ([]ListUpcomingInvitedEventsRow, error) {
	rows, err := q.db.Query(ctx, listUpcomingInvitedEvents, arg.StartsAt, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUpcomingInvitedEventsRow
	for rows.Next() {
		var i ListUpcomingInvitedEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Title,
			&i.Description,
			&i.StartsAt,
			&i.EndsAt,
			&i.Location,
			&i.UniqueLink,
			&i.PrivacySetting,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingOwnedEvents = `-- name: ListUpcomingOwnedEvents :many
SELECT id,
       owner_id,
       title,
       description,
       starts_at,
       ends_at,
       location,
       unique_link,
       privacy_setting,
       created_at,
       updated_at
FROM events
WHERE starts_at > $1
  AND owner_id = $2
ORDER BY starts_at
`

type ListUpcomingOwnedEventsParams struct {
	StartsAt pgtype.Timestamptz
	OwnerID  int32
}

func (q *Queries) ListUpcomingOwnedEvents(ctx context.Context, arg ListUpcomingOwnedEventsParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, listUpcomingOwnedEvents, arg.StartsAt, arg.OwnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Title,
			&i.Description,
			&i.StartsAt,
			&i.EndsAt,
			&i.Location,
			&i.UniqueLink,
			&i.PrivacySetting,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEvent = `-- name: UpdateEvent :exec
UPDATE events
set title           = $2,
    description     = $3,
    starts_at       = $4,
    ends_at         = $5,
    location        = $6,
    unique_link     = $7,
    privacy_setting = $8,
    updated_at      = $9
WHERE id = $1
RETURNING id, owner_id, title, description, starts_at, ends_at, location, unique_link, privacy_setting, created_at, updated_at
`

type UpdateEventParams struct {
	ID             int32
	Title          string
	Description    pgtype.Text
	StartsAt       pgtype.Timestamptz
	EndsAt         pgtype.Timestamptz
	Location       pgtype.Text
	UniqueLink     pgtype.Text
	PrivacySetting string
	UpdatedAt      pgtype.Timestamptz
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) error {
	_, err := q.db.Exec(ctx, updateEvent,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.StartsAt,
		arg.EndsAt,
		arg.Location,
		arg.UniqueLink,
		arg.PrivacySetting,
		arg.UpdatedAt,
	)
	return err
}

const updateInvitationResponseStatus = `-- name: UpdateInvitationResponseStatus :exec
UPDATE invitations
SET status = $2, responded_at = $3
WHERE id = $1
`

type UpdateInvitationResponseStatusParams struct {
	ID          int32
	Status      string
	RespondedAt pgtype.Timestamptz
}

func (q *Queries) UpdateInvitationResponseStatus(ctx context.Context, arg UpdateInvitationResponseStatusParams) error {
	_, err := q.db.Exec(ctx, updateInvitationResponseStatus, arg.ID, arg.Status, arg.RespondedAt)
	return err
}
